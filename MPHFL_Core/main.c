
/*

  Generated by Sony PSP Application AppWizard

  Version : 2.0.0

  File : main.c

  Description : main file for psp projet

*/


// *** INCLUDES ***

#include "Utils/config.h"
#include "Utils/driver.h"
#include <pspsdk.h>
#include <pspdebug.h>
#include <pspkernel.h>
#include <pspdisplay.h>
#include <pspctrl.h>


// *** DEFINES ***

#define _printf					pspDebugScreenPrintf

#define MAIN_TITLE				"MPH FIRMWARE LAUNCHER"
#define MAIN_VERSION			"1.4.0"

#define MAIN_FILE_CONFIG		"/mphfl.inf"

#define MAIN_KEYNAME_DRIVER		"DRIVER"
#define	MAIN_KEYNAME_OPTION		"OPTION"

#define MAIN_VARNAME_FLASH0		"Flash0_Folder"
#define MAIN_VARNAME_FLASH1		"Flash1_Folder"
#define	MAIN_VARNAME_DEBUGPRINT	"DebugPrint"
#define	MAIN_VARNAME_LOGFILE	"LogFile"
#define	MAIN_VARNAME_OLDSYSTEM	"OldSystem"

#define	MAIN_MODULE_COUNT		8


// *** STRUCTURES ***

typedef struct MainOption	// Main options
{
 u32 debugPrint;			// If 1, print debug message
 u32 oldSystem;				// If 1, use old root system instead new driver system
 u32 logFile;				// If 1, create a log file
} MainOption;


// *** GLOBALS VARIABLES ***

char mainPath[DRIVER_SIZE_PATH];			// Path of the program
MainOption mainOption;						// Options

char *mainModule[MAIN_MODULE_COUNT] =		// Module to start for vshell
{
 "flash0:/kd/chkreg.prx",
 "flash0:/kd/msaudio.prx",
 "flash0:/kd/vshbridge.prx",
 "flash0:/vsh/module/heaparea1.prx",
 "flash0:/vsh/module/paf.prx",
 "flash0:/vsh/module/common_gui.prx",
 "flash0:/vsh/module/common_util.prx",
 "flash0:/vsh/module/vshmain.prx"
};


// *** FUNCTIONS DECLARATIONS ***

extern u32 sceKernelSearchModuleByName (const char *);
u32 waitButton (u32, u32);
u32 loadStartModule (char *, u32);
char *findPath (const char *);
u32 patchEntry (SceModule *);


// *** MODULE INITIALISATION ***

PSP_MODULE_INFO("MPHFL_Core",0x1000,1,1);
PSP_MAIN_THREAD_ATTR(0x0);
PSP_HEAP_SIZE_KB(10);						 // pour compatibilité avec 1.00 ?


// *** INIT, FINI FUNCTIONS ***

__attribute__ ((constructor)) void init (void)
{
 pspKernelSetKernelPC();
 pspSdkInstallNoDeviceCheckPatch();
 pspSdkInstallNoPlainModuleCheckPatch();

 //pspDebugInstallKprintfHandler(NULL);
 //pspDebugScreenSetTextColor(0xFF);
}


// *** FUNCTIONS CALLBACKS ***

int CallbackExit (int arg1, int arg2, void *common)
{
 sceKernelExitGame();

 return 0;
}

int CallbackThread (SceSize args, void *argp)
{
 int cbid;


 cbid = sceKernelCreateCallback("ExitCallback",CallbackExit,NULL);
 sceKernelRegisterExitCallback(cbid);

 sceKernelSleepThreadCB();

 return 0;
}

int SetupCallbacks (void)
{
 int thid;


 thid = sceKernelCreateThread("UpdateThread",CallbackThread,0x11,0xFA0,PSP_THREAD_ATTR_USER,0);
 if (thid >= 0) sceKernelStartThread(thid,0,0);

 return thid;
}

int KeyThread (SceSize args, void *argp)
{
 SceCtrlData pad;
 u32 oldButtons = 0;


 // Key loop
 for (;;)
 {
  // Read the buttons
  sceCtrlReadBufferPositive(&pad,1);

  // Check the buttons
  if (oldButtons != pad.Buttons)
  {
   if ((pad.Buttons & PSP_CTRL_LTRIGGER) && (pad.Buttons & PSP_CTRL_RTRIGGER)) break;
  }

  // Save the buttons
  oldButtons = pad.Buttons;

  // Update other thread
  sceKernelDelayThread(50000);
 }

 // Uninstall driver
 driverUninstall(0);

 // Show exit screen
 pspDebugScreenInit();
 pspDebugScreenClear();

 // Exit game
 sceKernelExitGame();

 return 0;
}

// *** FUNCTIONS ***

u32 waitButton (u32 codemask, u32 block)
{
 SceCtrlData pad;
 static u32 oldButtons = 0;
 

 for (;;)
 {
  // Read the buttons
  sceCtrlReadBufferPositive(&pad,1);

  // Check the buttons
  if ((oldButtons != pad.Buttons) || (!(block)))
  {
   // Save the buttons
   oldButtons = pad.Buttons;

   // Exit if ok
   if (pad.Buttons & codemask) return pad.Buttons;
  }

  // For wait without block
  sceDisplayWaitVblankStart();
 }
}

u32 loadStartModule (char *path, u32 start)
{
 u32 loadResult, startResult;
 int status;


 loadResult = sceKernelLoadModule(path,0,NULL);
 if (loadResult & 0x80000000) return 1;

 if (start)
 {
  startResult = sceKernelStartModule(loadResult,0,NULL,&status,NULL);
  if (loadResult != startResult) return 2;
 }

 return 0;
}

char *findPath (const char *name)
{
 static char string[DRIVER_SIZE_PATH];


 // Copy main path
 strcpy(string,mainPath);

 // Copy name
 strcat(string,name);

 return string;
}

u32 patchEntry (SceModule *modMem)
{
 SceLibraryEntryTable *entryTable, *entryEnd;


 // Print info
 if (mainOption.debugPrint)
 {
  _printf("modMem : 0x%X\n",((u32) modMem));
  _printf("modMem->modname : %s\n",modMem->modname);
  _printf("modMem->attribute : 0x%X\n",modMem->attribute);
 }

 // If bad module
 if ((((long) modMem) & 0xFF000000) != 0x88000000) return 1;
 if ((modMem->stub_top - modMem->ent_top) < 40) return 1;

 // Patch name and attributes
 modMem->attribute = 0x1006;
 modMem->modname[0] = '*';

 // Find entry table info
 entryTable = (SceLibraryEntryTable *) ((u32 *) modMem->ent_top);
 entryEnd = (SceLibraryEntryTable *) (((u8 *) modMem->ent_top) + modMem->ent_size);

 // Entry loop
 while (entryTable < entryEnd)
 {
  // Print info
  if (mainOption.debugPrint)
  {
   _printf("entryTable : 0x%X\n",((u32) entryTable));
   _printf("entryTable->libname : %s\n",((entryTable->libname) ? entryTable->libname : "NULL"));
   _printf("entryTable->stubcount : %d\n",entryTable->stubcount);
   _printf("entryTable->vstubcount : %d\n",entryTable->vstubcount);
  }

  // Wait else crashes ??
  sceKernelDelayThread(20000);

  // Patch lib name
  if (entryTable->libname) ((char *) entryTable->libname)[0] = '*';

  // Next entry
  entryTable = (SceLibraryEntryTable *) (((u32 *) entryTable) + entryTable->len);
 }

 return 0;
}

int main (int argc, char *argv[])
{
 ConfigFile file;
 ConfigVariable *var;
 DriverConf conf;
 int error, x;


 // Init display and HOME button
 pspDebugScreenInit();
 pspDebugScreenClear();
 SetupCallbacks();

 // Setup Pad
 sceCtrlSetSamplingCycle(0);
 sceCtrlSetSamplingMode(0);

 // Find the path of program
 strcpy(mainPath,argv[0]);

 // Initialize variables
 memset(&conf,0,sizeof(DriverConf));
 memset(&mainOption,0,sizeof(MainOption));
 file.opened = 0;

 // Open configuration file
 configLoad(&file,findPath(MAIN_FILE_CONFIG));

 // Read flash0 folder
 if (!(configRead(&file,MAIN_KEYNAME_DRIVER,MAIN_VARNAME_FLASH0,&var)))
 {
  if (var->type == CONFIG_TYPE_STRING)
  {
   strncpy(conf.folderF0,(char *) var->value,DRIVER_SIZE_PATH - 1);
   conf.folderF0[DRIVER_SIZE_PATH - 1] = 0;
  }
 }

 // Read flash1 folder
 if (!(configRead(&file,MAIN_KEYNAME_DRIVER,MAIN_VARNAME_FLASH1,&var)))
 {
  if (var->type == CONFIG_TYPE_STRING)
  {
   strncpy(conf.folderF1,(char *) var->value,DRIVER_SIZE_PATH - 1);
   conf.folderF1[DRIVER_SIZE_PATH - 1] = 0;
  }
 }

 // Read debug print
 if (!(configRead(&file,MAIN_KEYNAME_OPTION,MAIN_VARNAME_DEBUGPRINT,&var)))
 {
  if (var->type == CONFIG_TYPE_INTEGER) mainOption.debugPrint = (*((u32 *) var->value)) ? 1 : 0;
 }

 // Read log file
 // Problem with logfile file when browser is opened the logfile fd is closed maybe because sceIoCloseAll called
 if (!(configRead(&file,MAIN_KEYNAME_OPTION,MAIN_VARNAME_LOGFILE,&var)))
 {
  if (var->type == CONFIG_TYPE_INTEGER) mainOption.logFile = (*((u32 *) var->value)) ? 1 : 0;
 }

 // Read old system
 if (!(configRead(&file,MAIN_KEYNAME_OPTION,MAIN_VARNAME_OLDSYSTEM,&var)))
 {
  if (var->type == CONFIG_TYPE_INTEGER) mainOption.oldSystem = (*((u32 *) var->value)) ? 1 : 0;
 }

 // Close configuration file
 configClose(&file,0,NULL);

 // Install drivers
 if (mainOption.oldSystem)
 {
  sceIoUnassign("flash0:");
  sceIoAssign("flash0:","msstor0p1:","fatms0:",IOASSIGN_RDWR,NULL,0);

  sceIoUnassign("flash1:");
  sceIoAssign("flash1:","msstor0p1:","fatms0:",IOASSIGN_RDWR,NULL,0);

  sceIoAssign("mphfl0:","msstor0p1:","fatms0:",IOASSIGN_RDWR,NULL,0);
 }
 else
  driverInstall(&conf,mainOption.logFile);

 if (mainOption.debugPrint)
 {
  // Infos show
  _printf("%s %s\n\n\n",MAIN_TITLE,MAIN_VERSION);

  if (mainOption.oldSystem)
   _printf("Firmware location (old format) :\n\nflash0 -> Memory card root\nflash1 -> Memory card root\nLogfile : Not used in old version\n\n");
  else
   _printf("Firmware location :\n\nflash0 -> %s\nflash1 -> %s\nLogfile : %s\n\n",conf.folderF0,conf.folderF1,((mainOption.logFile) ? DRIVER_DEFAULT_LOGFILE : "No log file"));

  _printf("Use L + R TRIGGER for quit emulation\n");
  _printf("Press X for begin emulation ...\n");

  waitButton(PSP_CTRL_CROSS,1);
 }

 // For general
 patchEntry(sceKernelFindModuleByName("sceMesgLed"));
 loadStartModule("mphfl0:/kd/mesg_led.prx",1);

 patchEntry(sceKernelFindModuleByName("sceKernelUtils"));
 loadStartModule("mphfl0:/kd/utils.prx",1);

 patchEntry(sceKernelFindModuleByName("scePWM_Driver"));
 loadStartModule("mphfl0:/kd/pwm.prx",1);

 patchEntry(sceKernelFindModuleByName("sceRTC_Service"));
 loadStartModule("mphfl0:/kd/rtc.prx",1);

// patchEntry(sceKernelFindModuleByName("sceUSB_Driver")); // no enough block for other module loaded by vshmain if loaded
// LoadStartModule("mphfl0:/kd/usb.prx",1);

 // For video
 patchEntry(sceKernelFindModuleByName("sceMeCodecWrapper"));
 loadStartModule("mphfl0:/kd/me_wrapper.prx",1);

 // For video 2.50
 //LoadStartModule("mphfl0:/kd/mgvideo.prx",1);

 // For audio AVC
 loadStartModule("mphfl0:/kd/peq.prx",1);

 patchEntry(sceKernelFindModuleByName("sceVaudio_driver"));
 loadStartModule("mphfl0:/kd/vaudio.prx",1);

 // For network
 sceKernelFindModuleByName("sceWlan_Driver")->attribute = 0x1006;
 x = sceKernelSearchModuleByName("sceWlan_Driver");
 
 sceKernelStopModule(x,0,NULL,NULL,NULL);
 sceKernelUnloadModule(x);
 loadStartModule("mphfl0:/kd/wlan.prx",1); 
 
 patchEntry(sceKernelFindModuleByName("sceRegistry_Service"));
 loadStartModule("mphfl0:/kd/registry.prx",1); 

 patchEntry(sceKernelFindModuleByName("sceUtility_Driver"));
 loadStartModule("mphfl0:/kd/utility.prx",1);

 // Load modules
 for (x=0,error=0;x<MAIN_MODULE_COUNT;x++)
 {
  if (loadStartModule(mainModule[x],1))
  {
   // Error occured
   error = 1;

   // Print message
   if (mainOption.debugPrint) _printf("Error : %s\n",mainModule[x]);

   // Exit loop
   break;
  }
 }

 // Exit if error
 if (error)
 {
  // Wait button if debug print
  if (mainOption.debugPrint)
  {
   _printf("Press X for exit ...\n");
   waitButton(PSP_CTRL_CROSS,1);
  }

  // Uninstall driver
  driverUninstall(0);

  // Exit
  sceKernelExitGame();

  return 1;
 }

 // Wait before creating thread key else can crash
 sceKernelDelayThread(50000);

 // Thread Key exit
 x = sceKernelCreateThread("ThreadKey",KeyThread,0x11,0xFA0,PSP_THREAD_ATTR_USER,0);
 if (x >= 0) sceKernelStartThread(x,0,0);

 return 0;
}
